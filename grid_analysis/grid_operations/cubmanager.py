#!/usr/bin/env python

# JACoPO.py: calculation of electronic couplings with various approaches.
# Copyright (C) 2016  Daniele Padula, Marco Campetella
# dpadula85@yahoo.it, marco.campetella82@gmail.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import numpy as np

class Cube:
    def __init__(self, fname):

        f = open(fname, 'r')
        for i in range(2): f.readline()
        # number of atoms included in the file followed by the 
        # position of the origin of the volumetric data
        tkns = f.readline().split()
        self.natoms = int(tkns[0])
        self.origin = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The next three lines give the number of voxels 
        # along each axis (x, y, z) followed by the axis vector.
        tkns = f.readline().split() #
        self.NX = int(tkns[0])
        self.X = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NY = int(tkns[0])
        self.Y = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NZ = int(tkns[0])
        self.Z = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The last section in the header is one line for each atom consisting of 5 numbers, the 
        #first is the atom number, second (?), the last three are the x,y,z coordinates of the atom center.
        self.atoms = []
        for i in range(self.natoms):
            tkns = list(map(float, f.readline().split()))
            self.atoms.append([tkns[0], tkns[2], tkns[3], tkns[4]])

        # Other data
        self.atoms = np.array(self.atoms)
        self.grid = self.gen_grid()
        self.dV = self.X[0] * self.Y[1] * self.Z[2]
        self.coords = np.array([ [x[1], x[2], x[3]] for x in self.atoms ])

        # Volumetric data
        self.data = np.zeros((self.NX,self.NY,self.NZ))
        i=0
        for s in f:
            #print(s.split())
            for v in s.split():
                self.data[int(i/(self.NY*self.NZ)),
                          int((i/self.NZ)%self.NY),
                          int(i%self.NZ)] = float(v)
                i+=1

        self.data = self.data.reshape(self.NX * self.NY * self.NZ)
        if i != self.NX*self.NY*self.NZ: raise NameError("FSCK!")


    def gen_grid(self):

        grid = np.zeros((self.NX, self.NY, self.NZ, 3))
        for i in range(self.NX):
            for j in range(self.NY):
                for k in range(self.NZ):
                    grid[i,j,k,0] = self.origin[0] + i * self.X[0]
                    grid[i,j,k,1] = self.origin[1] + j * self.Y[1]
                    grid[i,j,k,2] = self.origin[2] + k * self.Z[2]

        N = self.NX * self.NY * self.NZ
        return grid.reshape(N, 3)


    def dump(self, fname):

        with open(fname, 'w') as f:
            # output Gaussian cube into file descriptor "f".
            # Usage pattern: f=open('filename.cube'); cube.dump(f); f.close()
            self.data = self.data.reshape(self.NX, self.NY, self.NZ)
            f.write("CUBE file\nGenerated by JACoPO.py\n")
            f.write("%5d %12.6f %12.6f %12.6f\n" % (self.natoms, self.origin[0], self.origin[1], self.origin[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NX, self.X[0], self.X[1], self.X[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NY, self.Y[0], self.Y[1], self.Y[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NZ, self.Z[0], self.Z[1], self.Z[2]))
            for atom in self.atoms:
                f.write("%5d %12.6f %12.6f %12.6f %12.6f\n" % (atom[0], atom[0], atom[1], atom[2], atom[3]))
            for ix in range(self.NX):
                for iy in range(self.NY):
                    for iz in range(self.NZ):
                        f.write("%.5e " % self.data[ix,iy,iz])
                        if (iz % 6 == 5): f.write('\n')

if __name__ == '__main__':
    pass
